+++
title = "Spring Specification (Criteria)"
weight = 40
+++

> [!ressource] Ressources
> - [Pourquoi Spring à créer les Spécifications](https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl)
> - [Documentation](https://docs.spring.io/spring-data/jpa/reference/jpa/specifications.html)

## Définition
> If you are a long time JPA user you might answer: isn't that what the Criteria API is for? Right, so let's have a look what a sample business requirement implementation could look like using the JPA Criteria API.

```java
LocalDate today = LocalDate.now();

// Initialiser CriteriaBuilder et CriteriaQuery pour la requête sur l'entité Customer
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<Customer> query = builder.createQuery(Customer.class);
Root<Customer> root = query.from(Customer.class);

// Définir les prédicats pour :
// - Les clients dont c'est l'anniversaire aujourd'hui
// - Les clients ayant un compte créé il y a plus de deux ans
Predicate hasBirthday = builder.equal(root.get("birthday"), today);
Predicate isLongTermCustomer = builder.lessThan(root.get("createdAt"), today.minusYears(2));

// Appliquer les conditions dans la clause WHERE en combinant les prédicats
query.where(builder.and(hasBirthday, isLongTermCustomer));

// Exécuter la requête et retourner la liste des résultats
return em.createQuery(query.select(root)).getResultList();
```

> What do we have here? We create a new LocalDate for convenience and go on with three lines of boilerplate to set up the necessary JPA infrastructure instances. Then we have two lines building the predicates, one to concatenate both and a last one to execute the actual query. We're using the meta-model classes introduced with JPA 2.0 and generated by the Annotation Processing API. The main problem with this code is that the predicates are not easy to externalize and reuse because you need to set up the `CriteriaBuilder`, `CriteriaQuery` and `Root` first. Also, readability of the code is poor as it is hard to quickly infer the intent of the code upon first glance.

## L'arrivé des spécifications
> To be able to define reusable Predicates we introduced the Specification interface. The actually only consists of a single method

```java
public interface Specification<T> {
    Predicate toPredicate(Root<T> root, CriteriaQuery query, CriteriaBuilder cb);
}
```

On peut donc écrire nos prédicat dans une classe utilitaire 
```java
public CustomerSpecifications {

    public static Specification<Customer> customerHasBirthday() {
        return new Specification<Customer> {
        public Predicate toPredicate(Root<T> root, CriteriaQuery query, CriteriaBuilder cb) {
            return cb.equal(root.get(Customer_.birthday), today);
        }
        };
    }

    // Note : ici on a utiliser une lambda expression 
    public static Specification<Customer> isLongTermCustomer() {
        return (root, query, cb) -> cb.lessThan(root.get("createdAt"), LocalDate.now().minusYears(2));
    }
}
```

### Utilisation de la spécification
```java
public interface CustomerRepository extends JpaRepository<Customer, Long>, JpaSpecificationExecutor<Customer> {
  // Your query methods here
}
```

Et la classe Service pourra utiliser nos spécifications
```java
customerRepository.findAll(hasBirthday());
customerRepository.findAll(isLongTermCustomer());
```
